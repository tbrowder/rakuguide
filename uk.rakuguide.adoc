= Вступ до Raku
Naoum Hankache <naoum@hankache.com>; Dmytro Iaskolko <mescalito.ua@gmail.com>;
:description:  Загальна інтродукція до Raku
:keywords: perl6, Raku, introduction, perl6intro, Raku introduction, Raku tutorial, Raku intro, raku, raku introduction, raku guide, raku tutorial, вступ, введення до Raku, інтродукція до 6, вивчення perl6
:Email: naoum@hankache.com
:Revision: 1.0
:icons: font
:source-highlighter: pygments
//:pygments-style: manni
:source-language: perl6
:pygments-linenums-mode: table
:toc: left
:toc-title: Зміст
:doctype: book
:lang: uk

Цей документ має на меті надати швидкий огляд мови програмування Raku.
Новачкам у Raku цей документ надасть можливість почати вивчення та виркористання цієї мови.

Деякі розділи цього документа посилаються на інші (більш досконалі та точні) частини https://docs.raku.org[документації до Raku].
Вам слід прочитати їх, якщо потребуєте більше інформації на окремі теми.

Всюди у цьому документі ви знайдете приклади до найбільш обговорюваних тем. Аби краще їх зрозуміти, будь ласка, знайдіть трохи часу аби відтворити їх.

.Ліцензії
Цей документ ліцензовано за міжнародною ліцензією Creative Commons Attribution Share-Alike 4.0 (Із зазначенням авторства — Розповсюдження на тих самих умовах).
Аби побачити копію цієї лізензії, перейдіть за посиланням:

* https://creativecommons.org/licenses/by-sa/4.0/.

.Долучення
Якщо ви хочете долучитися до вдосконалення цього документа, перейдіть до:

* https://github.com/hankache/rakuguide

.Відгуки
Будь-які відгуки вдячно приймають на:

* naoum@hankache.com - English
* mescalito.ua@gmail.com - Українська

Якщо вам сподобалася ця робота, позначте зірочкою репозиторій за посиланням: link:https://github.com/hankache/rakuguide[Github].

.Переклади
* Болгарський: https://raku.guide/bg
* Китайський: https://raku.guide/zh
* Голландський: https://raku.guide/nl
* Французький: https://raku.guide/fr
* Німецький: https://raku.guide/de
* Індонезійський: https://raku.guide/id
* Італійський https://raku.guide/it
* Японський: https://raku.guide/ja
* Португальський: https://raku.guide/pt
* Іспаньский: https://raku.guide/es
* Турецький: https://raku.guide/tr
* Украінський: https://raku.guide/uk

:sectnums:

== Вступ
=== Що таке Raku
Raku це високорівнева мова програмування загального призначення з поступовою типізацією.
Raku є багатопарадигмальною мовою, яка підтримує процедурне, об'єктно-орієнтоване та функціональне програмування.

.Гасло Raku: 
* ІБНОСЗЦ Існує більш ніж один спосіб зробити це. TMTOWTDI (Вимовляється Tiм Tоуді).
* Прості речі мають лишатися простими, складні мають простішати, а неможливі мають стати складними.

=== Визначення
* *Raku*: Позначення  мови програмування в межах добірки тестів.
Реалізації, які проходять добірку тестів без помилок, вважаються Raku.
* *Rakudo*: Компілятор Raku.
* *Rakudobrew*: менеджер встановлення Rakudo.
* *Zef*: менеджер модулів Raku.
* *Rakudo Star*: колекція, яка містить Rakudo, Zef, добірку модулів Raku та документацію.

=== Встановлення Raku.
.Linux

Аби встановити Rakudo Star, виконайте наступні команди у своєму терміналі:
----
mkdir ~/rakudo && cd $_
curl -LJO https://rakudo.org/latest/star/src
tar -xzf rakudo-star-*.tar.gz
mv rakudo-star-*/* .
rm -fr rakudo-star-*

./bin/rstar install

echo "export PATH=$(pwd)/bin/:$(pwd)/share/perl6/site/bin:$(pwd)/share/perl6/vendor/bin:$(pwd)/share/perl6/core/bin:\$PATH" >> ~/.bashrc
source ~/.bashrc
----
Аби дізнатися про інші способи, перейдіть до https://rakudo.org/star/source

.macOS
Доступними є чотири варіанти:

* Дотримуватися тих самих кроків, що й для Linux
* Встановити через homebrew: `brew install rakudo-star`
* Встановити з MacPorts: `sudo port install rakudo` 
* Завантажити найсвіжіший встановлювач з https://rakudo.perl6.org/downloads/star/ (файл з розширенням .dmg)

.Windows
. Завантажте останній встановлювач (файл з розширенням .msi) з https://rakudo.perl6.org/downloads/star/ +
Якщо у вас 32-бітна система, завантажте файл х86; якщо 64-бітна, файл х86_64.
. Піcля встановлення переконайтеся,  що `C:\rakudo\bin` додано до змінної PATH.

.Docker
. Отримайте офіційний образ для Docker `docker pull rakudo-star`
. Далі запустіть контейнер з цим образом `docker run -it rakudo-star`

=== Виконання коду Raku

Виконувати код Raku можна в режимі інтерактивного інтерпретатора команд або REPL (Read-Eval-Print Loop). Для цього відкрийте вікно термінала, наберіть `raku` та натисніть [Enter]. Це призведе до появи запрошення `>`. Далі, наберіть рядок коду та натисніть [Enter], інтерпретатор надрукує значення або результат виконання цього рядка. Далі ви можете ввести інший рядок, або набрати `exit` та натиснути [Enter] аби завершити сесію інтерпретатора.

Також ви можете записати свій код у файл, зберегти та виконати його. Є рекомендованим надавати скриптам Raku розширення `.raku`. Виконати такий файл можна набравши `raku ваш_скрипт.raku` у термінальному вікні та натиснувши [Enter]. На відміну від інтерактивного режиму це не призведе до негайного друку результатів виконання коду: код має містити команди на кшталт `say` аби надрукувати результати виконання.

Інтерактивний режим здебільшого вживають, коли треба виконати якийсь конкретний фрагмент коду, зазвичай єдиний рядок. Програми більші за один рядое краще зберігати у файл і потім виконувати їх. 

Один рядок можна також виконати з командного рядка в неінтерактивному режимі,  написавши `raku -e 'ваш код тут'` та натиснувши [Enter].

[TIP]
--
Rakudo Star вже містить редактор, який  допоможе вам отримати якнайбільше від інтерактивного режиму.

Якщо ви встановили звичайний Rakudo замість Rakudo Star, тоді ви, можливо, не маєте змоги редагувати рядки (стрілки вгору та вниз для навігації по історії, ліворуч та праворуч для редагування поточного рядку, TAB для автодоповненя). Виконайте наступні команди, аби отримати все це:

* `zef install Linenoise` спрацює на Windows, Linux та MacOS
* `zef install Readline` якщо у вас Linux та ви полюбляєте бібліотеку _Readline_
--

=== Текстові редактори

Оскільки більшість часу ми писатимемо та зберігатимемо наші програми Raku у файлах, нам стане у пригоді будь-який пристойний текстовий редактор, який розуміє синтаксис Raku.

Особисто я надаю перевагу http://www.vim.org/[Vim], автор оригінального (англомовного) тексту використовує https://atom.io/[Atom] - це модерні текстові редактори, які вміють  підсвічувати синтаксис Raku одразу після встановлення. https://atom.io/packages/language-perl6[Raku FE] це альтернативний плагін для підсвічування синтаксису, який походить від оригінального пакету, але містить багато виправлень та доповнень. 
	
Інші люди у спільноті користуються https://www.gnu.org/software/emacs/[Emacs] чи http://padre.perlide.org/[Padre].

Свіжі версії Vim розуміють синтаксис Raku одразу після встановлення, Emacs та Padre  потребують встановлення додаткових пакетів.


=== Вітаю Світ!

Ми почнемо з ритуалу `Вітаю світ`.

[source,perl6]
say 'Вітання Світові!';

Це також може бути написане як

[source,perl6]
'Вітаю світ!'.say;

===  Огляд синтаксису

Raku є *вільною за формою* мовою: більшість часу ви можете використовувати довільну кількість пробілів, проте у певних випадках  пробіл  має значення.

*Твердження* це, зазвичай, логічний рядок коду, який має закінчуватися крапкою з комою:
[source,perl6]
----
say "Hello" if True;
say "World" if False;
----

Крапка з комою не є обовʼязковою після останнього твердження у файлі чи блоку коду, але  є доброю практикою додавати її у будь-якому випадку.

*Блоки*  можуть складатися з набору тверджень. Візьміть твердження у фігурні скобки аби створити блок:
[source,perl6]
----
{
    say "Перше твердження у блоці.";
    say "Друге треврдження у блоці.";
}
----

*Вираз* це спеціальний тип твердження, який повертає значення:
`1+2` поверне `3`

*Значення* бувають:

* *Змінними*: це значення, якими можна керувати та їх міняти.
* *Літералами*: це сталі значення, як число чи рядок.

*Оператори* класифіковані за типами:

|===

| *Тип* | *Пояснення* | *Приклад*

| Префіксні | Перед значенням | ++1

| Інфіксні | Між значеннями | 1+2

| Постфіксні | Після значення | 1++

| Контейнерні | Навколо значення | (1)

| Постконтейнерні | Після значення, навколо іншого | Array[1]

|===

==== Ідентифікатори

Ідентифікатори - це імена, які ви даєте значенням, коли визначаете їх.

.Правила:
* Вони мають починатися з алфавітного символа, чи нижнього  підкреслювання
* Вони можуть містити числа, за винятком першого символа
* Вони можуть містити дефіси та апострофи, (за винятком першої та останньої позиції) за умови, що праворуч від кожного дефіса чи апострофа знаходиться алфавітний символ.

|===

| Вірно | Невірно

| var1 | 1var

| var-one | var-1

| var'one | var'1

| var1_ | var1'

| _var1 | -var

| змінна1 | 1змінна

|=== 

.Угода іменування

* Стиль верблюда: `variableNo1`

* Шашличний стиль: `variable-no1`

* Стиль змії: `variable_no1`

Ви можете довільно іменувати ваші ідентифікатори, але ознакою гарного тону є використання якогось одного стилю.

Використання осмислених назв полегшить ваше життя (та життя інших).

* `var1 = var2 * var3` синтаксично вірно, але призначення кожної змінної не є очевидним.
* `monthly-salary = daily-rate * working-days` значно кращій варіант іменування змінних. 
 
==== Коментарі
Коментар - це текст, ігнорований компілятором, який слугує для пояснення (саме пояснення, а не цитування) коду.

Коментарі поділяють на три типи:

* Однорядкові:
[source,perl6]
# Це коментар в один рядок

* Вбудовані:
[source,perl6]
say #`(Це вбудований коментар) "Hello World."

* Багаторядкові:
[source,perl6]
-----------------------------
=begin comment
Це багаторядковий коментар.
Коментар 1
Коментар 2
=end comment
-----------------------------

==== Лапки
Рядки мають бути обмежені поодинокими чи подвійними лапками.

Завжди використовуйте подвійні лапки якщо:

* Ваш рядок містить апостроф.

* Ваш рядок містить змінну, яку має бути розгорнуто.

[source,perl6]
-----------------------------------
say 'Вітаю, Світ';   # Вітаю, Світ 
say "Вітаю, світ";   # Вітаю, Світ
say "Об'єм";         # Об'єм
my $name = 'Андрій Кузьменко';
say 'Вітаю $name';   # Вітаю $name
say "Вітаю $name";   # Вітаю Андрій Кузьменко
-----------------------------------

== Оператори

=== Загальні оператори
У таблиці нижче перераховані найбільш уживані оператори.
[cols="^.^5m,^.^5m,.^20,.^20m,.^20m", options="header"]
|===

| Оператор | Тип | Опис | Приклад | Результат

| + | Інфіксний | Додавання | 1 + 2 | 3

| - | Інфіксний | Віднімання | 3 - 1 | 2

| * | Інфіксний | Множення | 3 * 2 | 6

| ** | Інфіксний | Ступінь | 3 ** 2 | 9

| / | Інфіксний | Ділення | 3 / 2 | 1.5

| div | Інфіксний | Цілочисленне ділення (округлення до меншого) | 3 div 2 | 1

| % | Інфіксний | Залишок від ділення | 7 % 4 | 3

.2+| %% .2+| Інфіксний .2+| Ділимість | 6 %% 4 | False

<| 6 %% 3 <| True

| gcd | Інфіксний | Найбільший спільній дільник | 6 gcd 9 | 3

| lcm | Інфіксний | Найменше спільне кратне | 6 lcm 9 | 18

| == | Інфіксний | Арифметичне порівняння | 9 == 7  | False

| != | Інфіксний | Арифметичне не дорівнює | 9 != 7  | True

| < | Інфіксний | Менше | 9 < 7  | False

| > | Інфіксний | Більше | 9 > 7  | True

| \<= | Інфіксний | Менше чи дорівнює | 7 \<= 7  | True

| >= | Інфіксний | Більше чи дорівнює | 9 >= 7  | True

| eq | Інфіксний | Текстове порівняння | "John" eq "John"  | True

| ne | Інфіксний | Текстове не дорівнює | "John" ne "Jane"  | True

| = | Інфіксний | Привласнення | my $var = 7  | Присвоює значення `7` змінній `$var`

.2+| ~ .2+| Інфіксний .2+| Злиття рядків | 9 ~ 7 | 97

<m| "Вітаю " ~ "вас"  <| Вітаю вас

.2+| x .2+| Інфіксний .2+| Повторення рядків | 13 x 3  | 131313

<| "Вітаю " x 3  <| Вітаю Вітаю Вітаю

.5+| ~~ .5+| Інфіксний .5+| Розумний пошук входження | 2 ~~ 2  | True

<| 2 ~~ Int <| True

<| "Raku" ~~ "Raku" <| True

<| "Raku" ~~ Str <| True

<| "enlightenment" ~~ /light/ <| ｢light｣

.2+| ++ | Префіксний | Інкремент | my $var = 2; ++$var;  | Збільшити змінну на 1 та повернути результат `3`

<m| Постфіксний <d| Інкремент <m| my $var = 2; $var++;  <| Повернути `2` а помтім збільшити змінну на 1

.2+|\--| Префіксний | Декремент | my $var = 2; --$var;  | Зменшити змінну на 1 та повернути результат `1`

<m| Постфіксний <d| Декремент <m| my $var = 2; $var--;  <| Повернути змінну `2` по тому зменшити її на `1`

.3+| + .3+| Префіксний .3+| Привести операнд до числового типу | +"3"  | 3

<| +True <| 1

<| +False <| 0

.3+| - .3+| Префіксний .3+| Привести операнд до числового типу та інвертувати знак | -"3"  | -3

<| -True <| -1

<| -False <| 0

.6+| ? .6+| Префіксний .6+| Привести операнд до логічного типу | ?0 | False

<| ?9.8 <| True

<| ?"Вітаю" <| True

<| ?"" <| False

<| my $var; ?$var; <| False

<| my $var = 7; ?$var; <| True

| ! | Префіксний | Привести операнд до логічного типу та повернути протилежне значення | !4 | False

| .. | Інфіксний | Конструктор  послідовностей |  0..5  | Створює послідовність від 0 до 5

| ..^ | Інфіксний | Конструктор  послідовностей |  0..^5  | Створює послідовність від 0 до 4

| ^.. | Інфіксний | Конструктор  послідовностей |  0^..5  | Створює  послідовність від 1 до 5

| \^..^ | Інфіксний | Конструктор  послідовностей |  0\^..^5  | Створює послідовність від 1 до 4. Також відомий під назвою "котик".

| ^ | Префіксний | Конструктор  послідовностей |  ^5  | Те саме що 0..^5 Створює послідовність від 0 до 4

| ... | Інфіксний | Ледащий конструктор списків |  0...9999  | Повертає послідовність на вимогу 

.2+| {vbar} .2+| Префіксний .2+| Сплощення | {vbar}(0..5)  | (0 1 2 3 4 5)

<| {vbar}(0\^..^5)  <| (1 2 3 4)

|===

=== Зворотні оператори

Додавання R перед будь-яким оператором призведе до обертання напрямку їх дії.

[cols=".^m,.^m,.^m,.^m", options="header"]
|===

| Звичайний оператор | Результат | Зворотній оператор | Результат

| 2 / 3 | 0.666667 | 2 R/ 3 | 1.5

| 2 - 1 | 1 | 2 R- 1 | -1

|===


=== Оператори згортання

Оператори згортання працюють зі списками значень.

[cols=".^m,.^m,.^m,.^m", options="header"]
|===
| Звичайний оператор | Результат | Оператор згортання | Результат

| 1 + 2 + 3 + 4 + 5 | 15 | [+] 1,2,3,4,5 | 15

| 1 * 2 * 3 * 4 * 5 | 120 | [*] 1,2,3,4,5 | 120

|===

NOTE: Аби отримати повний список операторів разом з їх пріоритетами, перейдіть до https://docs.raku.org/language/operators

== Змінні

Змінні Raku класифіковано за трьома категоріями: скаляри, масиви, та хеші (асоціативні масиви).

*Сигіл* ("Знак" Латиною) - це символ, який слугує префіксом для категоризації змінних.

* `$` позначає скаляри

* `@` позначає масиви

* `%` позначає хеші

=== Скаляри

Скаляр зберігає єдине значення чи посилання

[source,perl6]
----
# Рядок
my $name = 'Андрій Кузьменко';
say $name;

# Ціле число
my $age = 99;
say $age;
----

Залежно від значення, яке зберігає скаляр,  над ним можна виконувати певний набір операцій.

[source,perl6]
.Рядок
----
my $name = 'Андрій Кузьменко';
say $name.uc;
say $name.chars;
say $name.flip;
----

----
АНДРІЙ КУЗЬМЕНКО
16
окнемьзуК йірднА
----

NOTE: Аби переглянути повний список методів, які придатні до застосування до рядків перейдіть до  https://docs.raku.org/type/Str

[source,perl6]
.Ціле число
----
my $age = 17;
say $age.is-prime;
----

----
True
----

NOTE: Аби дізнатися про повний список методів, які придатні до застосування до цілих чисел перейдіть до https://docs.raku.org/type/Int

[source,perl6]
.Раціональне число 
----
my $age = 2.3;
say $age.numerator;
say $age.denominator;
say $age.nude;
----

----
23
10
(23 10)
----

NOTE: Аби дізнатися про повний список методів, які придатні до застосування до раціональних чисел перейдіть до https://docs.raku.org/type/Rat

=== Масиви

Масиви - це списки, які містять багато значень

[source,perl6]
----
my @animals = 'верблюд','лама','сова';
say @animals;
----

Багато операцій може бути виконано надо масивами, як показано в наступному прикладі:

TIP: Тільда `~` призначена для конкатенації рядків.

[source,perl6]
.`Програма`
----
my @animals = 'верблюд','вікунья','лама';
say "У зоопарку є " ~ @animals.elems ~ " тварин";
say "Ці тварини: " ~ @animals;
say "Я маю намір віддати до зоопарку сову";
@animals.push("сова");
say "Тепер у зоопарку є: " ~ @animals;
say "Перша тварина, яка в нас з'явилася, це " ~ @animals[0];
@animals.pop;
say "На жаль сова втекла та в нас лишилися: " ~ @animals;
say "Ми закриваємо зоопарк та залишаемо собі лише одну тварину";
say "Ми плануємо віддати: " ~ @animals.splice(1,2) ~ " та залишити " ~ @animals;
----

.`Вивід`
----
У зоопарку є 3 тварини
Ці тварини: верблюд вікунья лама
Я маю намір віддати до зоопарку сову
Тепер у зоопарку є: верблюд вікунья лама сова
Перша тварина, яка в нас з'явилася, це верблюд
На жаль сова втекла та в нас лишилися: верблюд вікунья лама
Ми закриваємо зоопарк та залишаємо собі лише одну тварину
Ми плануємо віддати: вікунья лама та залишити верблюд
----

.Пояснення
`.elems` повертає кількість елементів масиву. +
`.push()` додає один чи більше елементів в кінець масиву. +
Ми можемо звернутися до певного елемента масиву вказавши його положення `@animals[0]`. +
`.pop` видаляє останній елемент масиву та повертає його. +
`.splice(a,b)` видалить (та поверне) `b` елементів починаючи з позиції `a`.

==== Масиви фіксованого розміру

Оголошення звичайного масиву виглядає наступним чином:

[source,perl6]
my @array;

Звичайний масив може бути довільного розміру, тому його називають автоматично розширюваним. +
Такий масив приймає довільну кількість значень без будь-яких обмежень.

На противагу, ми можемо створити масив фіксованого розміру. +
Доступ до таких масивів є неможливим за межами їх визначеного розміру.

[source,perl6]
my @array[3];

Цей масив здатен зберігати лише 3 значення, з індексами від 0 до 2.

[source,perl6]
----
my @array[3];
@array[0] = "перше значення";
@array[1] = "друге значення";
@array[2] = "третє значення";
----

Ви не зможете додати четверте значення до такого масиву.

[source,perl6]
----
my @array[3];
@array[0] = "перше значення";
@array[1] = "друге значення";
@array[2] = "третє значення";
@array[3] = "четверте значення";
----

----
Index 3 for dimension 1 out of range (must be 0..2)
----

==== Багатовимірні масиви
Масиви, які ми бачили до цього часу є одновимірними. +
На щастя, у Raku ми можемо визначати багатовимірні масиви.

[source,perl6]
my @tbl[3;2];

Цей масив двовимірний.
Перший вимір може зберігати завбільшки 3 значення, та другий вимір не більше ніж 2 значення.

Думайте про нього, як про таблицю 3х2.

[source,perl6]
----
my @tbl[3;2];
@tbl[0;0] = 1;
@tbl[0;1] = "x";
@tbl[1;0] = 2;
@tbl[1;1] = "y";
@tbl[2;0] = 3;
@tbl[2;1] = "z";
say @tbl
----

----
[[1 x] [2 y] [3 z]]
----

.Візуальна репрезентація масива:
----
[1 x]
[2 y]
[3 z]
----

NOTE: Повну документацію про масиви можна знайти за посиланням: https://docs.raku.org/type/Array

==== Хеші (асоціативні масиви)
[source,perl6]
.Хеш - це набір пар Ключ/Значення.
----
my %capitals = ('UK','Лондон','Ukraine','Київ');
say %capitals;
----

[source,perl6]
.Інший - стислий - спосіб заповнення хеша:
----
my %capitals = (UK => 'London',Ukraine => 'Kyiv');
say %capitals;
----

Деякі методи, які можуть бути застосовані до хешів:
[source,perl6]
.`Програма`
----
my %capitals = (UK => 'Лондон', Ukraine => 'Київ');
%capitals.push: (France => 'Париж');
say %capitals.kv;
say %capitals.keys;
say %capitals.values;
say "Столиця Франції це: " ~ %capitals<France>;
----

.`Вивід`
----
(France Париж UK Лондон Ukraine Київ)
(France UK Ukraine)
(Київ Лондон Париж)
Столиця Франції це: Париж
----

.Пояснення
`.push: (ключ => 'Значення')` додає нову пару ключ/значення. +
`.kv` повертає список, який містить усі ключі та значення. +
`.keys` повертає список, який містить усі ключі. +
`.values` повертає список, який містить усі значення. +
Ви можете звернутися до необхідного значення у хеші, вказавши його ключ `%hash<ключ>`

NOTE: Повну довідку по хешам ви можете отримати тут: https://docs.raku.org/type/Hash

=== Типи
У попередніх прикладах ми не вказували типи значень, які мають зберігати змінні.

TIP: `.WHAT` поверне тип значення, збереженого у змінній.

[source,perl6]
----
my $var = 'Text';
say $var;
say $var.WHAT;

$var = 123;
say $var;
say $var.WHAT;
----

Як бачимо з прикладу наведеного вище, тип значення у `$var` спочатку був (Str), потім став (Int).

Такий стиль програмування називають динамічною типізацією. Динамічною в тому сенсі, що змінні можуть зберігати значення будь-якого типу.

Тепер спробуйте виконати приклад ничже: +
Зверніть увагу на `Int` перед ім'ям змінної.

[source,perl6]
----
my Int $var = 'Text';
say $var;
say $var.WHAT;
----

Цей код не буде виконано, натомість з'явиться помилка: `Type check failed in assignment to $var; expected Int but got Str`

Відмінність у тому, що ми заздалегідь вказали, що змінна має бути типу (Int).
Коли ми спробували присвоїти змінній значення типу (Str), компілятор повернув помилку.

Такий стиль програмування називають статичною типізацією. Статичною в тому сенсі, що тип змінної визначають перед тим, як присвоїти значення і він не може бути змінений.

Raku класифіковано як мову з *поступовою типізацією*, тобто вона дозволяє як *статичну*, так і *динамічну* типізацію.

.Масиви та хеши також можуть бути статично типізованими:
[source,perl6]
----
my Int @array = 1,2,3;
say @array;
say @array.WHAT;

my Str @multilingual = "Hello","Вітаю","Hallo","您好","안녕하세요","こんにちは";
say @multilingual;
say @multilingual.WHAT;

my Str %capitals = (UK => 'London', Ukraine => 'Kyiv');
say %capitals;
say %capitals.WHAT;

my Int %country-codes = (UK => 44, Ukraine => 38);
say %country-codes;
say %country-codes.WHAT;
----

.У списку нижче ви можете бачити найчастіше уживані типи:
Скоріш за все, ви ніколи не використаєте перші два - вони наведені для інформації.
[cols="^.^1m,.^3m,.^2m,.^1m, options="header"]
|===

| *Тип* | *Опис* | *Приклад* | *Результат*

| Mu | Корінь ієрархії типів Raku | |

| Any | Базовий клас за замовчуванням для усіх нових класів, та для більшості вбудованих класів | |

| Cool | Значення, яке може бути рядком та цілим числом одночасно | my Cool $var = 31; say $var.flip; say $var * 2; | 13 62

| Str | Рядок символів | my Str $var = "NEON"; say $var.flip; | NOEN

| Int | Ціле число (довільної точності) | 7 + 7 | 14

| Rat | Раціональне число (обмеженої точності) | 0.1 + 0.2 | 0.3

| Bool | Логічне значення | !True | False

|===

=== Інтроспекція (відображення)

Інтроспекція це процес отримання інформації про властивості об'єкта, такої як тип. +
В одному з попередніх прикладів ми використали `.WHAT` аби отримати тип змінної.

[source,perl6]
----
my Int $var;
say $var.WHAT;    # (Int)
my $var2;
say $var2.WHAT;   # (Any)
$var2 = 1;
say $var2.WHAT;   # (Int)
$var2 = "Hello";
say $var2.WHAT;   # (Str)
$var2 = True;
say $var2.WHAT;   # (Bool)
$var2 = Nil;
say $var2.WHAT;   # (Any)
----

Тип змінної, яка зберігає значення, має відношення до її значення. +
Тип явно оголошеної пустої змінної є типом, з яким її оголосили. +
Типом пустої змінної, тип якої не було оголошено явно, є `(Any)` +
Аби очистити значення змінної, треба присвоїти їй значення `Nil`.

=== Область видимості

Перш ніж вперше використати змінну, вона має бути оголошена.

У Raku існує декілька способів це зробити. Досі ми використовували `my`.

[source,perl6]
my $var=1;

Оголошення у вигляді `my` надає змінній область видимості.
Іншими словами, змінна буде досяжна лише у тому блоці, де вона була оголошена.

У Raku блок обмежений `{ }`.
Якщо межі блоку не знайдені, змінна буде досяжною у всьому скрипті Raku.

[source,perl6]
----
{
  my Str $var = 'Text';
  say $var;   # is accessible
}
say $var;   # is not accessible, returns an error
----

Оскільки змінна досяжна лише у межах блоку, те саме ім'я змінної можна використати також в іншому блоці.

[source,perl6]
----
{
  my Str $var = 'Text';
  say $var;
}
my Int $var = 123;
say $var;
----

=== Привласнення чи зв'язування?
У попередніх прикладах ми бачили як *привласнити* значення змінній. +
*Привласнення* виконують за допомогою оператора `=`.
[source,perl6]
----
my Int $var = 123;
say $var;
----

Ми маємо змогу змінити значення, привласнене змінній:

[source,perl6]
.Привласнення
----
my Int $var = 123;
say $var;
$var = 999;
say $var;
----

.`Виведення`
----
123
999
----

З іншого боку, ми не можемо змінити значення, яке є *зв'язаним* зі змінною. +
*Зв'язування* роблять за допомогою оператора `:=`.

[source,perl6]
.Зв'язування.
----
my Int $var := 123;
say $var;
$var = 999;
say $var;
----

.`Виведення`
----
123
Cannot assign to an immutable value
----

[source,perl6]
.Змінні можуть також бути зв'язаними з іншими змінними:
----
my $a;
my $b;
$b := $a;
$a = 7;
say $b;
$b = 8;
say $a;
----

.`Виведення`
----
7
8
----

Зв'язування змінних є двонаправленим. +
`$a := $b` та `$b := $a` мають однаковий ефект.

NOTE: Аби дізнатися більше про змінні, завітайте до https://docs.raku.org/language/variables

== Функції та мутатори

Важливо відрізняти функції та мутатори.
Функції не змінюють стан об'єкта, на якому їх було викликано.
Мутатори змінюють стан об'єкта.

[source,perl6,linenums]
.`Скрипт`
----
my @numbers = [7,2,4,9,11,3];

@numbers.push(99);
say @numbers;      #1

say @numbers.sort; #2
say @numbers;      #3

@numbers.=sort;
say @numbers;      #4
----

.`Виведення`
----
[7 2 4 9 11 3 99] #1
(2 3 4 7 9 11 99) #2
[7 2 4 9 11 3 99] #3
[2 3 4 7 9 11 99] #4
----

.Пояснення
`.push` це мутатор, він змінює стан об'єкту (#1)

`.sort` це функція; вона повертає відсортований масив, але не змінює стан вихідного масиву.

* (#2) показує, що було повернено відсортований масив.

* (#3) показує, що вихідний масив не було змінено.

Аби змусити функцію  поводитися, як мутатор, ми використовуємо `.=` замість `.` (#4) (Рядок 9 скрипта)

== Цикли та умови
Raku має багато варіантів будови умов та циклів.

=== if
Код буде виконано лише у разі задовільнення умови; тобто вираз має повернути істину.

[source,perl6]
----
my $age = 19;

if $age > 18 {
  say 'Welcome'
}
----
  
У Raku ми можемо поміняти місцями код та умову. +
Навіть якщо код та умову було поміняно місцями, перевірка умови завжди буде виконана першою.

[source,perl6]
----
my $age = 19;

say 'Welcome' if $age > 18;
----

Якщо умову не було задовільнено,  ми можемо вказати альтернативні блоки для виконання за допомогою 

* `else`
* `elsif`

[source,perl6]
----
# run the same code for different values of the variable
my $number-of-seats = 9;

if $number-of-seats <= 5 {
  say 'I am a sedan'
} elsif $number-of-seats <= 7 {
  say 'I am 7 seater'
} else {
  say 'I am a van'
}
----

=== unless
Заперечна версія `if` ("Якщо не") може бути записана за допомогою `unless`.

Наступний код:

[source,perl6]
----
my $clean-shoes = False;

if not $clean-shoes {
  say 'Clean your shoes'
}
----
 
може бути записаний як:

[source,perl6]
----
my $clean-shoes = False;

unless $clean-shoes {
  say 'Clean your shoes'
}
----

Заперечення у Raku виконують за допомогою `!` або `not`.

`unless (умова)` використовують замість `if not (умова)`.

`unless` не може мати блока `else`.

=== with

`with` поводиться як `if`, але перевіряє чи визначена змінна.

[source,perl6]
----
my Int $var=1;

with $var {
  say 'Hello'
}
----

Якщо ви виконуєте код без присвоєння значення змінній, нічого не станеться.
[source,perl6] 
----
my Int $var;

with $var {
  say 'Hello'
}
----

`without` це заперечена версія `with`. Ви можете порівняти її з `unless`.

Якщо першу умову `with` не було задовільнено, альтернативну путь може бути визначено за допомогою  `orwith`. +
`with` та `orwith` можна порівняти з `if` та `elsif`.

=== for

Цикл `for` використовують аби обходити значення у списках.

[source,perl6]
----
my @array = [1,2,3];

for @array -> $array-item {
  say $array-item * 100
}
----

Зверніть увагу, що ми створили ітераційну змінну `$array-item` та виконали операцію `*100` з кожним елементом масиву.

== given

`given` у Raku - це еквівалент виразу `switch` у інших мовах, але набагато більш потужний.

#TODO 
